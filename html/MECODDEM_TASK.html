
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>MECODDEM_TASK</title><meta name="generator" content="MATLAB 8.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2014-03-12"><meta name="DC.source" content="MECODDEM_TASK.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1></h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">------------------------------------------------------------------------------------- %%%</a></li><li><a href="#2">SCRIPT OF THE MECODDEM PROJECT                            %%%</a></li><li><a href="#3">("MEtacognitive COntrol During DEcision-Making" task)                 %%%</a></li><li><a href="#4">------------------------------------------------------------------------------------- %%%</a></li><li><a href="#5">Author: Maxime Maheu</a></li><li><a href="#6">Copyright (C) 2014</a></li><li><a href="#7">* M1 Cogmaster</a></li><li><a href="#8">* Behavior, Emotion and Basal Ganglia team</a></li><li><a href="#9">* Brain and Spine Institute</a></li><li><a href="#10">This program was written to study the computational and behavioral determinants of</a></li><li><a href="#11">metacognitive control during perceptual decision making (with multi-sampling)</a></li><li><a href="#12">------------------------------------------------------------------------------------- %%%</a></li><li><a href="#13">Clear the workspace, set the diary and the recording file</a></li><li><a href="#14">Define parameters</a></li><li><a href="#15">Start the trial</a></li><li><a href="#17">CONFIDENCE</a></li><li><a href="#18">Fitting the psychometric curve</a></li><li><a href="#20">In case of error</a></li><li><a href="#22">Fitting the OPIS model (Optimal Proactive Information Seeking)</a></li><li><a href="#23">Clear and save</a></li></ul></div><h2>------------------------------------------------------------------------------------- %%%<a name="1"></a></h2><h2>SCRIPT OF THE MECODDEM PROJECT                            %%%<a name="2"></a></h2><h2>("MEtacognitive COntrol During DEcision-Making" task)                 %%%<a name="3"></a></h2><h2>------------------------------------------------------------------------------------- %%%<a name="4"></a></h2><h2>Author: Maxime Maheu<a name="5"></a></h2><h2>Copyright (C) 2014<a name="6"></a></h2><h2>* M1 Cogmaster<a name="7"></a></h2><h2>* Behavior, Emotion and Basal Ganglia team<a name="8"></a></h2><h2>* Brain and Spine Institute<a name="9"></a></h2><h2>This program was written to study the computational and behavioral determinants of<a name="10"></a></h2><h2>metacognitive control during perceptual decision making (with multi-sampling)<a name="11"></a></h2><h2>------------------------------------------------------------------------------------- %%%<a name="12"></a></h2><h2>Clear the workspace, set the diary and the recording file<a name="13"></a></h2><pre class="codeinput"><span class="comment">% Clear the workspace and the command window, then set the diary</span>
clc;
<span class="comment">%clear all;</span>
diary <span class="string">'MeCoDDeM_project.txt'</span>;

<span class="comment">% DATA.Subject.Number = randi(1000,1,1);</span>
<span class="comment">% DATA.Subject.Group = upper(input('Subject group? (HS/OCD) ', 's'));</span>
<span class="comment">% DATA.Subject.Age = upper(input('Subject age? ', 's'));</span>
<span class="comment">% DATA.Subject.Initials = upper(input('Subject initials? ', 's'));</span>
<span class="comment">% DATA.Subject.Handedness = upper(input('Subject handedness? (L/R) ', 's'));</span>
<span class="comment">% DATA.Subject.Gender = upper(input('Subject gender? (M/F) ', 's'));</span>
<span class="comment">% DATA.Subject.Date = datestr(now);</span>
<span class="comment">%</span>
<span class="comment">% DATA.Files.Name = ['MeCoDDeMproject_' DATA.Subject.Group '_' DATA.Subject.Initials '_' num2str(DATA.Subject.Number)];</span>
</pre><h2>Define parameters<a name="14"></a></h2><pre class="codeinput"><span class="comment">% Set frequently used colors</span>
colors.black = [0 0 0];
colors.white = [255 255 255];
colors.gray = [128 128 128];
colors.red = [255 0 0];

<span class="comment">% Set frequently used keys</span>
KbName(<span class="string">'UnifyKeyNames'</span>);
keys.up = KbName(<span class="string">'UpArrow'</span>);
keys.down = KbName(<span class="string">'DownArrow'</span>);
keys.right = KbName(<span class="string">'RightArrow'</span>);
keys.left = KbName(<span class="string">'LeftArrow'</span>);
keys.space = KbName(<span class="string">'space'</span>);

<span class="comment">% Set paradigm parameters</span>
DATA.Paradigm.Step = 15; <span class="comment">% Step</span>
display.scale = 10;

<span class="comment">% Set display parameters</span>
display.screenNum = max(Screen(<span class="string">'Screens'</span>));
display.bkColor = colors.black;
display.dist = 60; <span class="comment">% cm</span>
display.width = 30; <span class="comment">% cm</span>
display.skipChecks = 1; <span class="comment">% Avoid Screen's timing checks and verbosity</span>

<span class="comment">% Set up dot parameters</span>
dots.nDots = round(1.5*(2*pi*((display.scale/2)^2))); <span class="comment">% Calculate the number of dots based on the aperture size</span>
dots.speed = 5;
dots.lifetime = 12;
dots.apertureSize = [display.scale display.scale];
dots.center = [0 0];
dots.color = colors.white;
dots.size = 5;
dots.coherence = 0.7;
dots.duration = 1; <span class="comment">% seconds</span>

<span class="comment">% Set a correponding table between dots angle (classic) and line angle (trigonometric)</span>
display.T1.line.table_a = [0:DATA.Paradigm.Step:359];
display.T1.line.table_b = [90:-DATA.Paradigm.Step:0];
display.T1.line.table_c = [360:-DATA.Paradigm.Step:91];
display.T1.line.table_c(:,1) = [];
display.T1.line.table = [display.T1.line.table_a;display.T1.line.table_b,display.T1.line.table_c];

<span class="comment">% Set type I forms parameters</span>
display.T1.tick = display.scale/2;
display.T1.circle.size = display.scale;
display.T1.circle.color = colors.white;
display.T1.line.size = display.scale;
display.T1.line.color = colors.red;
display.T1.triangle.size = display.scale;
display.T1.triangle.color = colors.red;

<span class="comment">% Set type II forms parameters</span>
display.T2.tick = display.scale/2;
display.rect1.size = display.scale;
display.rect1.color = colors.white;
display.rect2.color = colors.red;

<span class="comment">% Set the parameters for the phasis 1 (calibration phasis)</span>
DATA.Paradigm.Phasis1.Coherences_margin = .2
DATA.Paradigm.Phasis1.Coherences_level = [0.1:DATA.Paradigm.Phasis1.Coherences_margin:(1 - DATA.Paradigm.Phasis1.Coherences_margin)]; <span class="comment">% Define the list of coherence levels</span>
DATA.Paradigm.Phasis1.Coherences_level = transpose(DATA.Paradigm.Phasis1.Coherences_level); <span class="comment">% Transform it into a column</span>
DATA.Paradigm.Phasis1.Coherences_number = 20; <span class="comment">% Number of trials per coherence level</span>
DATA.Paradigm.Phasis1.Coherences = repmat(DATA.Paradigm.Phasis1.Coherences_level, DATA.Paradigm.Phasis1.Coherences_number, 1); <span class="comment">% Repeat each coherence level a certain number of time</span>
DATA.Paradigm.Phasis1.Coherences = Shuffle(DATA.Paradigm.Phasis1.Coherences); <span class="comment">% Shuffle it</span>
DATA.Paradigm.Phasis1.Trials = size(DATA.Paradigm.Phasis1.Coherences, 1); <span class="comment">% The phasis 1 total number of trials is the size of this coherence list</span>

<span class="comment">% Set the parameters for the phasis 2 (evidence accumulation phasis)</span>
DATA.Paradigm.Phasis2.Viewing_number = 2;
DATA.Paradigm.Phasis2.Facility_levels = [0,.05,.10,.15]; <span class="comment">% Decreasing difficulty index</span>
DATA.Paradigm.Phasis2.Accuracies_number = 5; <span class="comment">% Number of trials per accuracy level</span>
DATA.Paradigm.Phasis2.Accuracies_levels = [0.5:.05:(1 - ((DATA.Paradigm.Phasis2.Viewing_number - 1)*DATA.Paradigm.Phasis2.Facility_levels(end)))];
DATA.Paradigm.Phasis2.Accuracies = repmat(DATA.Paradigm.Phasis2.Accuracies_levels, 1, size(DATA.Paradigm.Phasis2.Facility_levels, 2)*DATA.Paradigm.Phasis2.Accuracies_number);
DATA.Paradigm.Phasis2.Accuracies = transpose(DATA.Paradigm.Phasis2.Accuracies);
DATA.Paradigm.Phasis2.Accuracies = Shuffle(DATA.Paradigm.Phasis2.Accuracies);
<span class="keyword">for</span> i = 1:1:size(DATA.Paradigm.Phasis2.Facility_levels, 2)
    DATA.Paradigm.Phasis2.Facilities(:,i) = [repmat(DATA.Paradigm.Phasis2.Facility_levels(i), 1, size(DATA.Paradigm.Phasis2.Accuracies_levels, 2)*DATA.Paradigm.Phasis2.Accuracies_number)];
<span class="keyword">end</span>
DATA.Paradigm.Phasis2.Facilities = DATA.Paradigm.Phasis2.Facilities( : );
DATA.Paradigm.Phasis2.Facilities = Shuffle(DATA.Paradigm.Phasis2.Facilities);
DATA.Paradigm.Phasis2.Design = [DATA.Paradigm.Phasis2.Accuracies DATA.Paradigm.Phasis2.Facilities (DATA.Paradigm.Phasis2.Accuracies + DATA.Paradigm.Phasis2.Facilities)];
DATA.Paradigm.Phasis2.Trials = 3<span class="comment">%size(DATA.Paradigm.Phasis2.Design, 1);</span>

<span class="comment">% Set the parameters for the phasis 3 (information seeking phasis)</span>
DATA.Paradigm.Phasis3.Trials = 0;

<span class="comment">% Get the total number of trials</span>
DATA.Paradigm.Trials = DATA.Paradigm.Phasis1.Trials + DATA.Paradigm.Phasis2.Trials + DATA.Paradigm.Phasis3.Trials;

<span class="keyword">try</span>
</pre><h2>Start the trial<a name="15"></a></h2><pre class="codeinput">    <span class="comment">% Open a window, set the display matrix and get the center of the screen</span>
    display = OpenWindow(display);
    display.center = display.resolution/2;

    <span class="comment">% Set the first phasis (calibration phasis)</span>
    Phasis_number = 1;

    <span class="keyword">for</span> Trial_number = 1:1:DATA.Paradigm.Trials
</pre><pre class="codeinput">        <span class="comment">% Display phasis 1 instructions</span>
        <span class="keyword">if</span> Trial_number == 1
            drawText(display, [0 0], <span class="string">'INSTRUCTIONS'</span>, colors.white, 40);
            <span class="comment">% Load instructions image</span>
            Screen(<span class="string">'Flip'</span>,display.windowPtr);
            <span class="keyword">while</span> KbCheck; <span class="keyword">end</span>
            KbWait;
        <span class="keyword">end</span>

        <span class="comment">% Display the information that it is a new stimulus</span>
        drawText(display, [0 2], <span class="string">'NOUVEAU STIMULUS'</span>, colors.white, 40);
        drawText(display, [0 -2], <span class="string">'(Appuyer sur n''importe quelle touche pour commencer)'</span>, colors.white, 20);
        Screen(<span class="string">'Flip'</span>,display.windowPtr);
        <span class="keyword">while</span> KbCheck; <span class="keyword">end</span>
        KbWait;

        <span class="comment">% STIMULUS</span>

        <span class="comment">% Define dots direction</span>
        dots.direction = display.T1.line.table_a(randi(size(display.T1.line.table_a)));
        DATA.Paradigm.Directions(Trial_number, 1) = dots.direction

        <span class="comment">% Define dots motion coherence</span>
        <span class="keyword">if</span> Phasis_number == 1
            dots.coherence = DATA.Paradigm.Phasis1.Coherences(Trial_number);
        <span class="keyword">elseif</span> Phasis_number == 2
            <span class="comment">% Get a coherence level according to a given performance</span>
            syms <span class="string">Target_coherence</span>
            DATA.Paradigm.Phasis2.Coherences(Trial_number - DATA.Paradigm.Phasis1.Trials, 1) = double(solve((1./(1 + exp(-DATA.Fit.Psychometric.SigFit(1)*(Target_coherence - DATA.Fit.Psychometric.SigFit(2))))) == DATA.Paradigm.Phasis2.Design(Trial_number - DATA.Paradigm.Phasis1.Trials, 1)));
            dots.coherence = DATA.Paradigm.Phasis2.Coherences(Trial_number - DATA.Paradigm.Phasis1.Trials);
        <span class="keyword">end</span>

        <span class="comment">% Draw fixation cross during 2 seconds</span>
        display = drawFixationCross(display);
        waitTill(2);

        <span class="comment">% Show the stimulus</span>
        movingDots_MxM(display, dots, dots.duration, DATA.Paradigm.Step);

        <span class="comment">% Black screen during 100 milisecond</span>
        Screen(<span class="string">'FillOval'</span>, display.windowPtr, display.bkColor);
        Screen(<span class="string">'Flip'</span>,display.windowPtr);
        waitTill(.1);

        <span class="keyword">if</span> Phasis_number == 2
            <span class="comment">% For each review</span>
            <span class="keyword">for</span> Review = 2:1:DATA.Paradigm.Phasis2.Viewing_number
                <span class="comment">% Get a coherence level according to a given performance</span>
                syms <span class="string">Target_coherence</span>
                DATA.Paradigm.Phasis2.Coherences(Trial_number - DATA.Paradigm.Phasis1.Trials, 3) = double(solve((1./(1 + exp(-DATA.Fit.Psychometric.SigFit(1)*(Target_coherence - DATA.Fit.Psychometric.SigFit(2))))) == DATA.Paradigm.Phasis2.Design(Trial_number - DATA.Paradigm.Phasis1.Trials, 1)));
                dots.coherence = DATA.Paradigm.Phasis2.Coherences(Trial_number - DATA.Paradigm.Phasis1.Trials);
                <span class="comment">% Save the difference between the first sample coherence and the second sample one</span>
                DATA.Paradigm.Phasis2.Coherences(Trial_number - DATA.Paradigm.Phasis1.Trials, 2) = DATA.Paradigm.Phasis2.Coherences(Trial_number - DATA.Paradigm.Phasis1.Trials, 3) - DATA.Paradigm.Phasis2.Coherences(Trial_number - DATA.Paradigm.Phasis1.Trials, 1);

                <span class="comment">% Draw fixation cross during 2 seconds</span>
                display = drawFixationCross(display);
                waitTill(2);

                <span class="comment">% Show the stimulus</span>
                movingDots_MxM(display, dots, dots.duration, DATA.Paradigm.Step);

                <span class="comment">% Black screen during 100 milisecond</span>
                Screen(<span class="string">'FillOval'</span>, display.windowPtr, display.bkColor);
                Screen(<span class="string">'Flip'</span>,display.windowPtr);
                waitTill(.1);
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">if</span> Phasis_number == 3
            <span class="comment">% Display choice</span>
        <span class="keyword">end</span>

        <span class="comment">% Get the response</span>
        display.T1.line.index = 1 <span class="comment">%randi(size(display.T1.line.table, 2)); % Column number</span>
        display.T1.line.angle = display.T1.line.table(2, display.T1.line.index);
        DATA.Answers.Initial_Direction(Trial_number, 1) = display.T1.line.angle;
        DATA.Answers.Direction(Trial_number, 1) = NaN

        <span class="keyword">while</span> true
            <span class="comment">% Check the keys press and get the RT</span>
            [keyIsDown, DATA.RTs.Perceptual_brut(Trial_number, 1), keyCode] = KbCheck;
            <span class="comment">% Update the arrow according to key press</span>
            drawT1Circle(display, DATA.Paradigm.Step);

            <span class="keyword">if</span> keyIsDown

                    <span class="keyword">if</span> keyCode(keys.down)
                        <span class="comment">% Increase angle with 1 step</span>
                        display.T1.line.index = display.T1.line.index + 1;
                        <span class="keyword">if</span> display.T1.line.index &gt; size(display.T1.line.table, 2)
                            display.T1.line.index = 1;
                        <span class="keyword">end</span>
                        display.T1.line.angle = display.T1.line.table(2, display.T1.line.index);

                    <span class="keyword">elseif</span> keyCode(keys.up)
                        <span class="comment">% Decrease angle with minues 1 step</span>
                        display.T1.line.index = display.T1.line.index - 1;
                        <span class="keyword">if</span> display.T1.line.index == 0
                            display.T1.line.index = size(display.T1.line.table, 2);
                        <span class="keyword">end</span>
                        display.T1.line.angle = display.T1.line.table(2, display.T1.line.index);

                    <span class="keyword">elseif</span> keyCode(keys.space)
                        DATA.Answers.Direction(Trial_number, 1) = display.T1.line.table(1, display.T1.line.index);
                        <span class="keyword">break</span>;
                    <span class="keyword">end</span>
            waitTill(.1);
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">% Compute perceptual RT (brut and weighted according to the initial direction)</span>
        <span class="keyword">if</span> DATA.Answers.Direction(Trial_number, 1) ~= NaN
            DATA.RTs.Perceptual_weighted(Trial_number, 1) = DATA.RTs.Perceptual_brut(Trial_number, 1)/abs(DATA.Answers.Direction(Trial_number, 1) - DATA.Answers.Initial_Direction(Trial_number, 1));
        <span class="keyword">elseif</span> DATA.Answers.Direction(Trial_number, 1) == NaN
            DATA.RTs.Perceptual_brut(Trial_number, 1) = NaN;
            DATA.RTs.Perceptual_weighted(Trial_number, 1) = NaN;
        <span class="keyword">end</span>

        <span class="comment">% Compute perceptual performance</span>
        <span class="keyword">if</span> DATA.Answers.Direction(Trial_number, 1) ~= NaN
            <span class="keyword">if</span> abs(DATA.Paradigm.Directions(Trial_number, 1) == DATA.Answers.Direction(Trial_number, 1))
                DATA.Answers.Correction(Trial_number, 1) = 1;
            <span class="keyword">elseif</span> abs(DATA.Paradigm.Directions(Trial_number, 1) ~= DATA.Answers.Direction(Trial_number, 1))
                DATA.Answers.Correction(Trial_number, 1) = 0;
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">% Black screen during 100 milisecond</span>
        Screen(<span class="string">'FillOval'</span>, display.windowPtr, display.bkColor);
        Screen(<span class="string">'Flip'</span>,display.windowPtr);
        waitTill(.1);
</pre><h2>CONFIDENCE<a name="17"></a></h2><pre class="codeinput">        display.rect2.size = randi([-display.rect1.size, display.rect1.size]);
        DATA.Answers.Initial_Confidence(Trial_number, 1) = round(((display.rect2.size + display.rect1.size) / (2 * display.rect1.size)) * 100);
        DATA.Answers.Confidence(Trial_number, 1) = NaN;

        <span class="keyword">while</span> true
            <span class="comment">% Check the keys press and get the RT</span>
            [keyIsDown, DATA.RTs.Confidence_brut(Trial_number, 1), keyCode] = KbCheck;

            <span class="comment">% Display instructions</span>
            <span class="keyword">if</span> Phasis_number == 1
                drawText(display, [0, (display.rect1.size - display.rect1.size/4)], <span class="string">'Veuillez donner votre niveau de confiance dans votre r&eacute;ponse'</span>, [255 255 255], 40);
            <span class="keyword">elseif</span> Phasis_number == 2 <span class="comment">% &agrave; modifier</span>
                drawText(display, [0, (display.rect1.size - display.rect1.size/4)], <span class="string">'Veuillez donner votre niveau de confiance dans votre r&eacute;ponse'</span>, [255 255 255], 40);
            <span class="keyword">elseif</span> Phasis_number == 3 <span class="comment">% &agrave; modifier</span>
                drawText(display, [0, (display.rect1.size - display.rect1.size/4)], <span class="string">'Veuillez donner votre niveau de confiance si vous aviez d&ucirc; r&eacute;pondre'</span>, [255 255 255], 40);
            <span class="keyword">end</span>
            drawText(display, [0, (display.rect1.size - display.rect1.size/4)*-1], <span class="string">'(Appuyer sur ESPACE pour valider votre choix)'</span>, [255 255 255], 20);

            <span class="comment">% Update the red rectangle according to key press</span>
            drawT2Rect(display);
            <span class="keyword">if</span> keyIsDown

                    <span class="keyword">if</span> keyCode(keys.right)
                        <span class="comment">% Increase confidence score with +1%</span>
                        display.rect2.size = display.rect2.size + ((2*display.rect1.size)/100);
                        <span class="keyword">if</span> display.rect2.size &gt; display.rect1.size
                        display.rect2.size = display.rect1.size;
                        <span class="keyword">end</span>

                    <span class="keyword">elseif</span> keyCode(keys.left)
                        <span class="comment">% Decrease confidence score with -1%</span>
                        display.rect2.size = display.rect2.size - ((2*display.rect1.size)/100);
                        <span class="keyword">if</span> display.rect2.size &lt; display.rect1.size*-1
                        display.rect2.size = display.rect1.size*-1;
                        <span class="keyword">end</span>

                    <span class="keyword">elseif</span> keyCode(keys.space)
                        <span class="comment">% Get the confidence score on a 100 scale</span>
                        DATA.Answers.Confidence(Trial_number, 1) = round(((display.rect2.size + display.rect1.size) / (2 * display.rect1.size)) * 100);
                        waitTill(.1);
                        <span class="keyword">break</span>;
                    <span class="keyword">end</span>
            <span class="keyword">end</span>

        <span class="keyword">if</span> DATA.Answers.Confidence(Trial_number, 1) ~= NaN
            DATA.RTs.Confidence_weighted(Trial_number, 1) = DATA.RTs.Confidence_brut(Trial_number, 1)/abs(DATA.Answers.Initial_Confidence(Trial_number, 1) - DATA.Answers.Confidence(Trial_number, 1)) <span class="comment">% &agrave; corriger</span>
        <span class="keyword">elseif</span> DATA.Answers.Confidence(Trial_number, 1) == NaN
            DATA.RTs.Confidence_brut(Trial_number, 1) = NaN;
            DATA.RTs.Confidence_weighted(Trial_number, 1) = NaN;
        <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">% Display a break screen</span>
        <span class="keyword">if</span> ((Trial_number == (DATA.Paradigm.Phasis1.Trials/2)) | (Trial_number == (DATA.Paradigm.Phasis2.Trials/2)) | (Trial_number == (DATA.Paradigm.Phasis3.Trials/2)))
            drawText(display, [0 2], <span class="string">'Fa&icirc;tes une pause d''une ou deux minutes'</span>, colors.white, 40);
            drawText(display, [0 -2], <span class="string">'(Appuyer sur n''importe quelle touche pour continuer)'</span>, colors.white, 20);
            Screen(<span class="string">'Flip'</span>,display.windowPtr);
            <span class="keyword">while</span> KbCheck; <span class="keyword">end</span>
            KbWait;
        <span class="keyword">end</span>
</pre><h2>Fitting the psychometric curve<a name="18"></a></h2><pre class="codeinput">        <span class="keyword">if</span> Phasis_number == 1
            <span class="keyword">if</span> Trial_number == DATA.Paradigm.Phasis1.Trials
                <span class="comment">% Make a coherence x performance table</span>
                DATA.Fit.Psychometric.Coherence = unique(DATA.Paradigm.Phasis1.Coherences);
                DATA.Fit.Psychometric.Performance = grpstats(DATA.Answers.Correction, DATA.Paradigm.Phasis1.Coherences);
                <span class="comment">% Insert born values (chance and 100% accuracy)</span>
                DATA.Fit.Psychometric.Chance = 1/(360/DATA.Paradigm.Step);
                DATA.Fit.Psychometric.Coherence = [0; DATA.Fit.Psychometric.Coherence];
                DATA.Fit.Psychometric.Performance = [DATA.Fit.Psychometric.Chance; DATA.Fit.Psychometric.Performance];
                DATA.Fit.Psychometric.Coherence = [DATA.Fit.Psychometric.Coherence; 1];
                DATA.Fit.Psychometric.Performance = [DATA.Fit.Psychometric.Performance; 1];
                <span class="comment">% Set the psychometric function</span>
                DATA.Fit.Psychometric.SigFunc = @(F, x)(1./(1 + exp(-F(1)*(x-F(2)))));
                <span class="comment">% Fit it</span>
                DATA.Fit.Psychometric.SigFit = nlinfit(DATA.Fit.Psychometric.Coherence, DATA.Fit.Psychometric.Performance, DATA.Fit.Psychometric.SigFunc, [1 1]);
                <span class="comment">% Draw the figure</span>
                figure(1)
                <span class="comment">% Plot empirical points</span>
                plot(DATA.Fit.Psychometric.Coherence, DATA.Fit.Psychometric.Performance, <span class="string">'*'</span>);
                hold <span class="string">on</span>
                <span class="comment">% Plot fit</span>
                plot(DATA.Fit.Psychometric.Coherence, DATA.Fit.Psychometric.SigFunc(DATA.Fit.Psychometric.SigFit, DATA.Fit.Psychometric.Coherence), <span class="string">'g'</span>);
                hold <span class="string">on</span>
                <span class="comment">% Draw theoretic curve based on fit</span>
                DATA.Fit.Psychometric.Theoretical_x = 0:0.001:1;
                DATA.Fit.Psychometric.Theoretical_y = sigmf(DATA.Fit.Psychometric.Theoretical_x, DATA.Fit.Psychometric.SigFit);
                plot(DATA.Fit.Psychometric.Theoretical_x, DATA.Fit.Psychometric.Theoretical_y, <span class="string">'r-.'</span>);
                hold <span class="string">on</span>
                <span class="comment">% Draw chance level</span>
                plot(DATA.Fit.Psychometric.Theoretical_x, DATA.Fit.Psychometric.Chance, <span class="string">'c-'</span>);
                <span class="comment">% Set legend, axis and labels</span>
                legend(<span class="string">'Data'</span>, <span class="string">'Fit'</span>, <span class="string">'Theoretical'</span>, <span class="string">'Chance'</span>, <span class="string">'location'</span>, <span class="string">'northwest'</span>);
                axis([0 1 0 1]);
                xlabel(<span class="string">'Motion coherence'</span>);
                ylabel(<span class="string">'Perceptual performance'</span>);
                <span class="comment">% Sauver le graphique</span>
                <span class="comment">%%%%%%%%%%%%%%% savefig(DATA.Files.Name, '.fig')</span>
                <span class="comment">% Get a coherence level according to a given performance</span>
                syms <span class="string">Target_coherence</span>
                DATA.Fit.Psychometric.C50 = double(solve((1./(1 + exp(-DATA.Fit.Psychometric.SigFit(1)*(Target_coherence - DATA.Fit.Psychometric.SigFit(2))))) == .5));
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">% Switch to phasis 2 when all the phasis 1 trials have been displayed</span>
        <span class="keyword">if</span> Trial_number == DATA.Paradigm.Phasis1.Trials
            Phasis_number = 2;
            <span class="comment">% Display instructions for phasis 2</span>
        <span class="keyword">end</span>
        <span class="comment">% Switch to phasis 3 when all the phasis 2 trials have been displayed</span>
        <span class="keyword">if</span> Trial_number == DATA.Paradigm.Phasis2.Trials
            Phasis_number = 3;
            <span class="comment">% Display instructions for phasis 3</span>
        <span class="keyword">end</span>
</pre><pre class="codeinput">    <span class="keyword">end</span>

    <span class="comment">% Close all windows</span>
    Screen(<span class="string">'CloseAll'</span>);
</pre><h2>In case of error<a name="20"></a></h2><pre class="codeinput"><span class="keyword">catch</span> error_message
Screen(<span class="string">'CloseAll'</span>);
rethrow(error_message);
<span class="keyword">end</span>
</pre><pre class="codeoutput">
DATA = 

    Paradigm: [1x1 struct]
     Answers: [1x1 struct]
         RTs: [1x1 struct]
         Fit: [1x1 struct]
       Files: [1x1 struct]

</pre><pre class="codeoutput">Subscripted assignment dimension mismatch.

Error in MECODDEM_TASK (line 113)
    DATA.Paradigm.Phasis2.Facilities(:,i) = [repmat(DATA.Paradigm.Phasis2.Facility_levels(i), 1, size(DATA.Paradigm.Phasis2.Accuracies_levels, 2)*DATA.Paradigm.Phasis2.Accuracies_number)];
</pre><h2>Fitting the OPIS model (Optimal Proactive Information Seeking)<a name="22"></a></h2><h2>Clear and save<a name="23"></a></h2><pre class="codeinput">DATA.Files.Name = <span class="string">'Temporaire'</span>
<span class="comment">% Save data</span>
save(DATA.Files.Name, <span class="string">'DATA'</span>, <span class="string">'display'</span>, <span class="string">'dots'</span>)
<span class="comment">% Save the summary dataset in a csv file(DataSet, 'File', DATA.Files.Name '.csv', 'Delimiter', ',')</span>

<span class="comment">% Clear some useless variables</span>
clear <span class="string">Phasis_number</span> <span class="string">and</span> <span class="string">Trial_number</span> <span class="string">and</span> <span class="string">Target_coherence</span> <span class="string">and</span> <span class="string">ans</span> <span class="string">and</span> <span class="string">i</span>;
<span class="comment">% Close the diary</span>
diary <span class="string">off</span>;
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2013a</a><br></p></div><!--
##### SOURCE BEGIN #####
%%% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH- %%%
%%%                             SCRIPT OF THE MECODDEM PROJECT                            %%%
%%%                 ("MEtacognitive COntrol During DEcision-Making" task)                 %%%
%%% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH- %%%

%%% Author: Maxime Maheu
%%% Copyright (C) 2014

%%% * M1 Cogmaster
%%% * Behavior, Emotion and Basal Ganglia team
%%% * Brain and Spine Institute

%%% This program was written to study the computational and behavioral determinants of
%%% metacognitive control during perceptual decision making (with multi-sampling)

%%% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH- %%%

%% Clear the workspace, set the diary and the recording file

% Clear the workspace and the command window, then set the diary
clc;
%clear all;
diary 'MeCoDDeM_project.txt';

% DATA.Subject.Number = randi(1000,1,1);
% DATA.Subject.Group = upper(input('Subject group? (HS/OCD) ', 's'));
% DATA.Subject.Age = upper(input('Subject age? ', 's'));
% DATA.Subject.Initials = upper(input('Subject initials? ', 's'));
% DATA.Subject.Handedness = upper(input('Subject handedness? (L/R) ', 's'));
% DATA.Subject.Gender = upper(input('Subject gender? (M/F) ', 's'));
% DATA.Subject.Date = datestr(now);
% 
% DATA.Files.Name = ['MeCoDDeMproject_' DATA.Subject.Group '_' DATA.Subject.Initials '_' num2str(DATA.Subject.Number)];

%% Define parameters

% Set frequently used colors
colors.black = [0 0 0];
colors.white = [255 255 255];
colors.gray = [128 128 128];
colors.red = [255 0 0];

% Set frequently used keys
KbName('UnifyKeyNames');
keys.up = KbName('UpArrow');
keys.down = KbName('DownArrow');
keys.right = KbName('RightArrow');
keys.left = KbName('LeftArrow');
keys.space = KbName('space');

% Set paradigm parameters 
DATA.Paradigm.Step = 15; % Step  
display.scale = 10;

% Set display parameters
display.screenNum = max(Screen('Screens'));
display.bkColor = colors.black;
display.dist = 60; % cm
display.width = 30; % cm
display.skipChecks = 1; % Avoid Screen's timing checks and verbosity

% Set up dot parameters
dots.nDots = round(1.5*(2*pi*((display.scale/2)^2))); % Calculate the number of dots based on the aperture size
dots.speed = 5;
dots.lifetime = 12;
dots.apertureSize = [display.scale display.scale];
dots.center = [0 0];
dots.color = colors.white;
dots.size = 5;
dots.coherence = 0.7;
dots.duration = 1; % seconds

% Set a correponding table between dots angle (classic) and line angle (trigonometric)
display.T1.line.table_a = [0:DATA.Paradigm.Step:359];
display.T1.line.table_b = [90:-DATA.Paradigm.Step:0];
display.T1.line.table_c = [360:-DATA.Paradigm.Step:91];
display.T1.line.table_c(:,1) = [];
display.T1.line.table = [display.T1.line.table_a;display.T1.line.table_b,display.T1.line.table_c];

% Set type I forms parameters
display.T1.tick = display.scale/2;
display.T1.circle.size = display.scale;
display.T1.circle.color = colors.white;
display.T1.line.size = display.scale;
display.T1.line.color = colors.red;
display.T1.triangle.size = display.scale;
display.T1.triangle.color = colors.red;

% Set type II forms parameters
display.T2.tick = display.scale/2;
display.rect1.size = display.scale;
display.rect1.color = colors.white;
display.rect2.color = colors.red;

% Set the parameters for the phasis 1 (calibration phasis)
DATA.Paradigm.Phasis1.Coherences_margin = .2
DATA.Paradigm.Phasis1.Coherences_level = [0.1:DATA.Paradigm.Phasis1.Coherences_margin:(1 - DATA.Paradigm.Phasis1.Coherences_margin)]; % Define the list of coherence levels
DATA.Paradigm.Phasis1.Coherences_level = transpose(DATA.Paradigm.Phasis1.Coherences_level); % Transform it into a column
DATA.Paradigm.Phasis1.Coherences_number = 20; % Number of trials per coherence level
DATA.Paradigm.Phasis1.Coherences = repmat(DATA.Paradigm.Phasis1.Coherences_level, DATA.Paradigm.Phasis1.Coherences_number, 1); % Repeat each coherence level a certain number of time
DATA.Paradigm.Phasis1.Coherences = Shuffle(DATA.Paradigm.Phasis1.Coherences); % Shuffle it
DATA.Paradigm.Phasis1.Trials = size(DATA.Paradigm.Phasis1.Coherences, 1); % The phasis 1 total number of trials is the size of this coherence list

% Set the parameters for the phasis 2 (evidence accumulation phasis)
DATA.Paradigm.Phasis2.Viewing_number = 2;
DATA.Paradigm.Phasis2.Facility_levels = [0,.05,.10,.15]; % Decreasing difficulty index
DATA.Paradigm.Phasis2.Accuracies_number = 5; % Number of trials per accuracy level
DATA.Paradigm.Phasis2.Accuracies_levels = [0.5:.05:(1 - ((DATA.Paradigm.Phasis2.Viewing_number - 1)*DATA.Paradigm.Phasis2.Facility_levels(end)))];
DATA.Paradigm.Phasis2.Accuracies = repmat(DATA.Paradigm.Phasis2.Accuracies_levels, 1, size(DATA.Paradigm.Phasis2.Facility_levels, 2)*DATA.Paradigm.Phasis2.Accuracies_number);
DATA.Paradigm.Phasis2.Accuracies = transpose(DATA.Paradigm.Phasis2.Accuracies);
DATA.Paradigm.Phasis2.Accuracies = Shuffle(DATA.Paradigm.Phasis2.Accuracies);
for i = 1:1:size(DATA.Paradigm.Phasis2.Facility_levels, 2)
    DATA.Paradigm.Phasis2.Facilities(:,i) = [repmat(DATA.Paradigm.Phasis2.Facility_levels(i), 1, size(DATA.Paradigm.Phasis2.Accuracies_levels, 2)*DATA.Paradigm.Phasis2.Accuracies_number)];
end
DATA.Paradigm.Phasis2.Facilities = DATA.Paradigm.Phasis2.Facilities( : );
DATA.Paradigm.Phasis2.Facilities = Shuffle(DATA.Paradigm.Phasis2.Facilities);
DATA.Paradigm.Phasis2.Design = [DATA.Paradigm.Phasis2.Accuracies DATA.Paradigm.Phasis2.Facilities (DATA.Paradigm.Phasis2.Accuracies + DATA.Paradigm.Phasis2.Facilities)];
DATA.Paradigm.Phasis2.Trials = 3%size(DATA.Paradigm.Phasis2.Design, 1);

% Set the parameters for the phasis 3 (information seeking phasis)
DATA.Paradigm.Phasis3.Trials = 0;

% Get the total number of trials
DATA.Paradigm.Trials = DATA.Paradigm.Phasis1.Trials + DATA.Paradigm.Phasis2.Trials + DATA.Paradigm.Phasis3.Trials;

try
    %% Start the trial
    
    % Open a window, set the display matrix and get the center of the screen
    display = OpenWindow(display);
    display.center = display.resolution/2;
      
    % Set the first phasis (calibration phasis)
    Phasis_number = 1;
    
    for Trial_number = 1:1:DATA.Paradigm.Trials
        
        % Display phasis 1 instructions
        if Trial_number == 1
            drawText(display, [0 0], 'INSTRUCTIONS', colors.white, 40);
            % Load instructions image
            Screen('Flip',display.windowPtr);
            while KbCheck; end
            KbWait;
        end
        
        % Display the information that it is a new stimulus
        drawText(display, [0 2], 'NOUVEAU STIMULUS', colors.white, 40);
        drawText(display, [0 -2], '(Appuyer sur n''importe quelle touche pour commencer)', colors.white, 20);
        Screen('Flip',display.windowPtr);
        while KbCheck; end
        KbWait;
        
        % STIMULUS
        
        % Define dots direction
        dots.direction = display.T1.line.table_a(randi(size(display.T1.line.table_a)));
        DATA.Paradigm.Directions(Trial_number, 1) = dots.direction
        
        % Define dots motion coherence
        if Phasis_number == 1
            dots.coherence = DATA.Paradigm.Phasis1.Coherences(Trial_number);
        elseif Phasis_number == 2
            % Get a coherence level according to a given performance
            syms Target_coherence
            DATA.Paradigm.Phasis2.Coherences(Trial_number - DATA.Paradigm.Phasis1.Trials, 1) = double(solve((1./(1 + exp(-DATA.Fit.Psychometric.SigFit(1)*(Target_coherence - DATA.Fit.Psychometric.SigFit(2))))) == DATA.Paradigm.Phasis2.Design(Trial_number - DATA.Paradigm.Phasis1.Trials, 1)));
            dots.coherence = DATA.Paradigm.Phasis2.Coherences(Trial_number - DATA.Paradigm.Phasis1.Trials);
        end
        
        % Draw fixation cross during 2 seconds
        display = drawFixationCross(display);
        waitTill(2);

        % Show the stimulus
        movingDots_MxM(display, dots, dots.duration, DATA.Paradigm.Step);

        % Black screen during 100 milisecond
        Screen('FillOval', display.windowPtr, display.bkColor);
        Screen('Flip',display.windowPtr);
        waitTill(.1);

        if Phasis_number == 2
            % For each review
            for Review = 2:1:DATA.Paradigm.Phasis2.Viewing_number
                % Get a coherence level according to a given performance
                syms Target_coherence
                DATA.Paradigm.Phasis2.Coherences(Trial_number - DATA.Paradigm.Phasis1.Trials, 3) = double(solve((1./(1 + exp(-DATA.Fit.Psychometric.SigFit(1)*(Target_coherence - DATA.Fit.Psychometric.SigFit(2))))) == DATA.Paradigm.Phasis2.Design(Trial_number - DATA.Paradigm.Phasis1.Trials, 1)));
                dots.coherence = DATA.Paradigm.Phasis2.Coherences(Trial_number - DATA.Paradigm.Phasis1.Trials);
                % Save the difference between the first sample coherence and the second sample one
                DATA.Paradigm.Phasis2.Coherences(Trial_number - DATA.Paradigm.Phasis1.Trials, 2) = DATA.Paradigm.Phasis2.Coherences(Trial_number - DATA.Paradigm.Phasis1.Trials, 3) - DATA.Paradigm.Phasis2.Coherences(Trial_number - DATA.Paradigm.Phasis1.Trials, 1);
                
                % Draw fixation cross during 2 seconds
                display = drawFixationCross(display);
                waitTill(2);

                % Show the stimulus
                movingDots_MxM(display, dots, dots.duration, DATA.Paradigm.Step);

                % Black screen during 100 milisecond
                Screen('FillOval', display.windowPtr, display.bkColor);
                Screen('Flip',display.windowPtr);
                waitTill(.1);
            end
        end
        
        if Phasis_number == 3
            % Display choice
        end

        % Get the response
        display.T1.line.index = 1 %randi(size(display.T1.line.table, 2)); % Column number
        display.T1.line.angle = display.T1.line.table(2, display.T1.line.index);
        DATA.Answers.Initial_Direction(Trial_number, 1) = display.T1.line.angle;
        DATA.Answers.Direction(Trial_number, 1) = NaN

        while true
            % Check the keys press and get the RT
            [keyIsDown, DATA.RTs.Perceptual_brut(Trial_number, 1), keyCode] = KbCheck;
            % Update the arrow according to key press
            drawT1Circle(display, DATA.Paradigm.Step);
                       
            if keyIsDown

                    if keyCode(keys.down)
                        % Increase angle with 1 step
                        display.T1.line.index = display.T1.line.index + 1;
                        if display.T1.line.index > size(display.T1.line.table, 2)
                            display.T1.line.index = 1;  
                        end
                        display.T1.line.angle = display.T1.line.table(2, display.T1.line.index);  

                    elseif keyCode(keys.up)
                        % Decrease angle with minues 1 step
                        display.T1.line.index = display.T1.line.index - 1;
                        if display.T1.line.index == 0
                            display.T1.line.index = size(display.T1.line.table, 2);
                        end
                        display.T1.line.angle = display.T1.line.table(2, display.T1.line.index);
                        
                    elseif keyCode(keys.space)
                        DATA.Answers.Direction(Trial_number, 1) = display.T1.line.table(1, display.T1.line.index);
                        break;
                    end
            waitTill(.1);
            end
        end

        % Compute perceptual RT (brut and weighted according to the initial direction)
        if DATA.Answers.Direction(Trial_number, 1) ~= NaN
            DATA.RTs.Perceptual_weighted(Trial_number, 1) = DATA.RTs.Perceptual_brut(Trial_number, 1)/abs(DATA.Answers.Direction(Trial_number, 1) - DATA.Answers.Initial_Direction(Trial_number, 1));
        elseif DATA.Answers.Direction(Trial_number, 1) == NaN
            DATA.RTs.Perceptual_brut(Trial_number, 1) = NaN;
            DATA.RTs.Perceptual_weighted(Trial_number, 1) = NaN;
        end

        % Compute perceptual performance
        if DATA.Answers.Direction(Trial_number, 1) ~= NaN
            if abs(DATA.Paradigm.Directions(Trial_number, 1) == DATA.Answers.Direction(Trial_number, 1))
                DATA.Answers.Correction(Trial_number, 1) = 1;
            elseif abs(DATA.Paradigm.Directions(Trial_number, 1) ~= DATA.Answers.Direction(Trial_number, 1))
                DATA.Answers.Correction(Trial_number, 1) = 0;
            end
        end            

        % Black screen during 100 milisecond
        Screen('FillOval', display.windowPtr, display.bkColor);
        Screen('Flip',display.windowPtr);
        waitTill(.1);

        %% CONFIDENCE

        display.rect2.size = randi([-display.rect1.size, display.rect1.size]);            
        DATA.Answers.Initial_Confidence(Trial_number, 1) = round(((display.rect2.size + display.rect1.size) / (2 * display.rect1.size)) * 100);
        DATA.Answers.Confidence(Trial_number, 1) = NaN;

        while true
            % Check the keys press and get the RT
            [keyIsDown, DATA.RTs.Confidence_brut(Trial_number, 1), keyCode] = KbCheck;
            
            % Display instructions
            if Phasis_number == 1
                drawText(display, [0, (display.rect1.size - display.rect1.size/4)], 'Veuillez donner votre niveau de confiance dans votre réponse', [255 255 255], 40);
            elseif Phasis_number == 2 % à modifier
                drawText(display, [0, (display.rect1.size - display.rect1.size/4)], 'Veuillez donner votre niveau de confiance dans votre réponse', [255 255 255], 40);
            elseif Phasis_number == 3 % à modifier
                drawText(display, [0, (display.rect1.size - display.rect1.size/4)], 'Veuillez donner votre niveau de confiance si vous aviez dû répondre', [255 255 255], 40);
            end
            drawText(display, [0, (display.rect1.size - display.rect1.size/4)*-1], '(Appuyer sur ESPACE pour valider votre choix)', [255 255 255], 20);
            
            % Update the red rectangle according to key press
            drawT2Rect(display);
            if keyIsDown

                    if keyCode(keys.right)
                        % Increase confidence score with +1%
                        display.rect2.size = display.rect2.size + ((2*display.rect1.size)/100);
                        if display.rect2.size > display.rect1.size
                        display.rect2.size = display.rect1.size;
                        end

                    elseif keyCode(keys.left)
                        % Decrease confidence score with -1%
                        display.rect2.size = display.rect2.size - ((2*display.rect1.size)/100);
                        if display.rect2.size < display.rect1.size*-1
                        display.rect2.size = display.rect1.size*-1;
                        end

                    elseif keyCode(keys.space)
                        % Get the confidence score on a 100 scale
                        DATA.Answers.Confidence(Trial_number, 1) = round(((display.rect2.size + display.rect1.size) / (2 * display.rect1.size)) * 100);
                        waitTill(.1);
                        break;
                    end
            end

        if DATA.Answers.Confidence(Trial_number, 1) ~= NaN
            DATA.RTs.Confidence_weighted(Trial_number, 1) = DATA.RTs.Confidence_brut(Trial_number, 1)/abs(DATA.Answers.Initial_Confidence(Trial_number, 1) - DATA.Answers.Confidence(Trial_number, 1)) % à corriger
        elseif DATA.Answers.Confidence(Trial_number, 1) == NaN
            DATA.RTs.Confidence_brut(Trial_number, 1) = NaN;
            DATA.RTs.Confidence_weighted(Trial_number, 1) = NaN;
        end
        end

        % Display a break screen
        if ((Trial_number == (DATA.Paradigm.Phasis1.Trials/2)) | (Trial_number == (DATA.Paradigm.Phasis2.Trials/2)) | (Trial_number == (DATA.Paradigm.Phasis3.Trials/2)))
            drawText(display, [0 2], 'Faîtes une pause d''une ou deux minutes', colors.white, 40);
            drawText(display, [0 -2], '(Appuyer sur n''importe quelle touche pour continuer)', colors.white, 20);
            Screen('Flip',display.windowPtr);
            while KbCheck; end
            KbWait;
        end

        %% Fitting the psychometric curve
        if Phasis_number == 1
            if Trial_number == DATA.Paradigm.Phasis1.Trials
                % Make a coherence x performance table
                DATA.Fit.Psychometric.Coherence = unique(DATA.Paradigm.Phasis1.Coherences);
                DATA.Fit.Psychometric.Performance = grpstats(DATA.Answers.Correction, DATA.Paradigm.Phasis1.Coherences);
                % Insert born values (chance and 100% accuracy)
                DATA.Fit.Psychometric.Chance = 1/(360/DATA.Paradigm.Step);
                DATA.Fit.Psychometric.Coherence = [0; DATA.Fit.Psychometric.Coherence];
                DATA.Fit.Psychometric.Performance = [DATA.Fit.Psychometric.Chance; DATA.Fit.Psychometric.Performance];
                DATA.Fit.Psychometric.Coherence = [DATA.Fit.Psychometric.Coherence; 1];
                DATA.Fit.Psychometric.Performance = [DATA.Fit.Psychometric.Performance; 1];
                % Set the psychometric function
                DATA.Fit.Psychometric.SigFunc = @(F, x)(1./(1 + exp(-F(1)*(x-F(2)))));
                % Fit it
                DATA.Fit.Psychometric.SigFit = nlinfit(DATA.Fit.Psychometric.Coherence, DATA.Fit.Psychometric.Performance, DATA.Fit.Psychometric.SigFunc, [1 1]);
                % Draw the figure
                figure(1)
                % Plot empirical points
                plot(DATA.Fit.Psychometric.Coherence, DATA.Fit.Psychometric.Performance, '*');
                hold on
                % Plot fit
                plot(DATA.Fit.Psychometric.Coherence, DATA.Fit.Psychometric.SigFunc(DATA.Fit.Psychometric.SigFit, DATA.Fit.Psychometric.Coherence), 'g');
                hold on
                % Draw theoretic curve based on fit
                DATA.Fit.Psychometric.Theoretical_x = 0:0.001:1;
                DATA.Fit.Psychometric.Theoretical_y = sigmf(DATA.Fit.Psychometric.Theoretical_x, DATA.Fit.Psychometric.SigFit);
                plot(DATA.Fit.Psychometric.Theoretical_x, DATA.Fit.Psychometric.Theoretical_y, 'r-.');
                hold on
                % Draw chance level
                plot(DATA.Fit.Psychometric.Theoretical_x, DATA.Fit.Psychometric.Chance, 'c-');
                % Set legend, axis and labels
                legend('Data', 'Fit', 'Theoretical', 'Chance', 'location', 'northwest');
                axis([0 1 0 1]);
                xlabel('Motion coherence'); 
                ylabel('Perceptual performance');
                % Sauver le graphique
                %%%%%%%%%%%%%%% savefig(DATA.Files.Name, '.fig')
                % Get a coherence level according to a given performance
                syms Target_coherence
                DATA.Fit.Psychometric.C50 = double(solve((1./(1 + exp(-DATA.Fit.Psychometric.SigFit(1)*(Target_coherence - DATA.Fit.Psychometric.SigFit(2))))) == .5));
            end
        end
        
        % Switch to phasis 2 when all the phasis 1 trials have been displayed
        if Trial_number == DATA.Paradigm.Phasis1.Trials
            Phasis_number = 2;
            % Display instructions for phasis 2
        end
        % Switch to phasis 3 when all the phasis 2 trials have been displayed
        if Trial_number == DATA.Paradigm.Phasis2.Trials
            Phasis_number = 3;
            % Display instructions for phasis 3
        end
    end
     
    % Close all windows
    Screen('CloseAll');

%% In case of error
catch error_message
Screen('CloseAll'); 
rethrow(error_message);
end

%% Fitting the OPIS model (Optimal Proactive Information Seeking)


%% Clear and save
DATA.Files.Name = 'Temporaire' 
% Save data
save(DATA.Files.Name, 'DATA', 'display', 'dots')
% Save the summary dataset in a csv file(DataSet, 'File', DATA.Files.Name '.csv', 'Delimiter', ',')

% Clear some useless variables
clear Phasis_number and Trial_number and Target_coherence and ans and i;
% Close the diary
diary off;
##### SOURCE END #####
--></body></html>